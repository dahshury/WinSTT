# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt6 UI code generator 6.6.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.

#! Fix: GPU-env and release, long outputs cutoff and live transcription (more compute intensive), 
#? Add: live system audio transcription with diarization (live subtitles), LLM Options: Translate, CODE, reformat (summerize, PII redaction, funny, academic, simple, formal), wake-word detection, more models.

# Disable terminal flashing
import subprocess
from unittest.mock import patch

# Add socket for single-instance check
import socket
import tempfile
import atexit

# Suppress pygame welcome message and warnings
import os
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "hide"
# Suppress libpng warnings - more thorough approach
os.environ['PYTHONWARNINGS'] = "ignore::DeprecationWarning:pygame"
os.environ['QT_LOGGING_RULES'] = "qt.gui.imageio=false"

# Import win32gui for handling existing window activation (Windows only)
if os.name == 'nt' or os.name == 'win32':
    try:
        import win32gui
        HAS_WIN32GUI = True
    except ImportError:
        HAS_WIN32GUI = False

# Create a unique socket name based on the app name
socket_name = os.path.join(tempfile.gettempdir(), 'winstt_single_instance.sock')

# Function to check for an existing instance
def is_already_running():
    global single_instance_socket
    try:
        # Try to create and bind a socket
        single_instance_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        single_instance_socket.bind(('localhost', 47123))  # Use a unique, unlikely-to-be-used port
        # If we get here, no other instance is running
        atexit.register(cleanup_socket)
        return False
    except socket.error:
        # Socket is already in use, another instance is running
        return True

# Function to clean up socket on exit
def cleanup_socket():
    global single_instance_socket
    if single_instance_socket:
        single_instance_socket.close()

# Save the original Popen method 
original_popen = subprocess.Popen

def suppress_subprocess_call(*args, **kwargs):
    # Suppress the console window
    CREATE_NO_WINDOW = 0x08000000
    kwargs['creationflags'] = kwargs.get('creationflags', 0) | CREATE_NO_WINDOW
    return original_popen(*args, **kwargs)

def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    try:
        base_path = sys._MEIPASS
    except Exception:
        base_path = (os.path.dirname(os.path.abspath(__file__)))

    return os.path.join(base_path, relative_path)

# Suppression patch
with patch("subprocess.Popen", side_effect=suppress_subprocess_call):
    from PyQt6 import QtCore, QtGui
    from PyQt6.QtWidgets import QSystemTrayIcon, QMenu, QSizePolicy, QWidget, QFrame, QLabel, QProgressBar, QCheckBox, QPushButton, QTextEdit, QMessageBox, QMainWindow, QGraphicsView, QComboBox, QApplication, QGraphicsOpacityEffect, QToolBar, QHBoxLayout, QDialog, QVBoxLayout, QDialogButtonBox, QFormLayout, QGroupBox, QGridLayout, QFileDialog
    from PyQt6.QtCore import QObject, pyqtSignal, QThread, QTimer, QPropertyAnimation, QTimer, QEasingCurve, Qt, QParallelAnimationGroup
    from PyQt6.QtGui import QAction, QIcon
    import sys
    import onnxruntime as ort
    import gc
    from utils.transcribe import WhisperONNXTranscriber, VaDetector
    from utils.listener import AudioToText
    from logger import setup_logger

    logger = setup_logger()

    class SettingsDialog(QDialog):
        def __init__(self, current_model, current_quantization, current_recording_sound, current_sound_path, output_srt, acc, parent=None):
            super().__init__(parent)
            self.setWindowTitle("Settings")
            self.setFixedSize(300, 250)  # Reduced height since we're removing buttons
            
            # Default values for settings
            self.default_model = "Whisper-Turbo"
            self.default_quantization = "Full" if acc else "Quantized"
            self.default_recording_sound = True
            self.default_sound_path = os.path.join(resource_path("./media/splash.mp3"))
            self.default_output_srt = False
            
            # Store current values
            self.current_model = current_model
            self.current_quantization = current_quantization
            self.current_recording_sound = current_recording_sound
            self.current_sound_path = current_sound_path
            self.current_output_srt = output_srt
            self.acc = acc
            
            # Get the parent window to apply changes
            self.parent_window = parent
            
            # Inherit palette from parent for theme consistency
            self.setPalette(self.parent().palette())
            
            # Main layout
            main_layout = QVBoxLayout(self)
            
            # Group box for model and quantization settings
            model_group = QGroupBox("Model Settings")
            model_group.setStyleSheet("""
                QGroupBox {
                    color: rgb(144, 164, 174);
                    border: 1px solid rgb(78, 106, 129);
                    border-radius: 3px;
                    margin-top: 10px;
                }
                QGroupBox::title {
                    subcontrol-origin: margin;
                    subcontrol-position: top left;
                    padding: 0 3px;
                }
            """)
            model_layout = QGridLayout()
            
            # Font for consistency
            font = QtGui.QFont("Roboto")
            
            # Set consistent button height
            button_height = 22
            
            # Model selection
            model_label = QLabel("Model:")
            model_label.setFont(font)
            model_label.setStyleSheet("color: rgb(144, 164, 174);")
            
            self.model_combo = QComboBox()
            self.model_combo.addItem("Whisper-Turbo")
            self.model_combo.setCurrentText(current_model)
            self.model_combo.setEnabled(acc)
            self.model_combo.setStyleSheet("""
                QComboBox {
                    background-color: rgb(54, 71, 84);
                    color: rgb(163, 190, 203);
                    border-style: outset;
                    border-radius: 3px;
                    border-width: 1px;
                    border-color: rgb(78, 106, 129);
                }
                QComboBox QAbstractItemView {
                    background-color: rgb(8, 11, 14);
                }
            """)
            
            # Reset button for model
            model_reset_btn = QPushButton()
            model_reset_btn.setToolTip("Reset to default model")
            model_reset_btn.setIcon(QIcon(resource_path("./media/Command-Reset-256.png")))
            model_reset_btn.setIconSize(QtCore.QSize(16, 16))  # 60% of original size (approx)
            model_reset_btn.setFixedSize(17, button_height)  # 30% smaller
            model_reset_btn.setStyleSheet("""
                QPushButton {
                    background-color: rgb(54, 71, 84);
                    border: 1px solid rgb(78, 106, 129);
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: rgb(78, 106, 129);
                }
            """)
            model_reset_btn.clicked.connect(self.reset_model)
            
            # Quantization selection
            quant_label = QLabel("Quantization:")
            quant_label.setFont(font)
            quant_label.setStyleSheet("color: rgb(144, 164, 174);")
            
            self.quant_combo = QComboBox()
            self.quant_combo.addItems(["Full", "Quantized"])
            self.quant_combo.setCurrentText(current_quantization)
            self.quant_combo.setStyleSheet("""
                QComboBox {
                    background-color: rgb(54, 71, 84);
                    color: rgb(163, 190, 203);
                    border-style: outset;
                    border-radius: 3px;
                    border-width: 1px;
                    border-color: rgb(78, 106, 129);
                }
                QComboBox QAbstractItemView {
                    background-color: rgb(8, 11, 14);
                }
            """)
            
            # Reset button for quantization
            quant_reset_btn = QPushButton()
            quant_reset_btn.setToolTip("Reset to default quantization")
            quant_reset_btn.setIcon(QIcon(resource_path("./media/Command-Reset-256.png")))
            quant_reset_btn.setIconSize(QtCore.QSize(16, 16))  # 60% of original size
            quant_reset_btn.setFixedSize(17, button_height)  # 30% smaller
            quant_reset_btn.setStyleSheet("""
                QPushButton {
                    background-color: rgb(54, 71, 84);
                    border: 1px solid rgb(78, 106, 129);
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: rgb(78, 106, 129);
                }
            """)
            quant_reset_btn.clicked.connect(self.reset_quantization)
            
            # Add to grid layout
            model_layout.addWidget(model_label, 0, 0)
            model_layout.addWidget(self.model_combo, 0, 1)
            model_layout.addWidget(model_reset_btn, 0, 2)
            model_layout.addWidget(quant_label, 1, 0)
            model_layout.addWidget(self.quant_combo, 1, 1)
            model_layout.addWidget(quant_reset_btn, 1, 2)
            
            model_group.setLayout(model_layout)
            
            # Form layout for remaining settings
            form_layout = QFormLayout()
            
            # Sound file selection
            sound_label = QLabel("Sound File:")
            sound_label.setFont(font)
            sound_label.setStyleSheet("color: rgb(144, 164, 174);")
            
            sound_widget = QWidget()
            sound_layout = QHBoxLayout(sound_widget)
            sound_layout.setContentsMargins(0, 0, 0, 0)
            
            self.sound_path_display = QLabel(current_sound_path if current_sound_path else "No file selected")
            self.sound_path_display.setStyleSheet("""
                color: rgb(163, 190, 203);
                background-color: rgb(54, 71, 84);
                border: 1px solid rgb(78, 106, 129);
                border-radius: 3px;
                padding: 2px 5px;
            """)
            self.sound_path_display.setFixedHeight(button_height)
            
            self.browse_btn = QPushButton("Browse...")
            self.browse_btn.setFixedHeight(button_height)
            self.browse_btn.setStyleSheet("""
                QPushButton {
                    background-color: rgb(54, 71, 84);
                    color: rgb(144, 164, 174);
                    border: 1px solid rgb(78, 106, 129);
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: rgb(78, 106, 129);
                }
            """)
            self.browse_btn.clicked.connect(self.browse_sound_file)
            
            sound_reset_btn = QPushButton()
            sound_reset_btn.setToolTip("Reset to default sound file")
            sound_reset_btn.setIcon(QIcon(resource_path("./media/Command-Reset-256.png")))
            sound_reset_btn.setIconSize(QtCore.QSize(16, 16))
            sound_reset_btn.setFixedSize(17, button_height)  # 30% smaller
            sound_reset_btn.setStyleSheet("""
                QPushButton {
                    background-color: rgb(54, 71, 84);
                    border: 1px solid rgb(78, 106, 129);
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: rgb(78, 106, 129);
                }
            """)
            sound_reset_btn.clicked.connect(self.reset_sound_path)
            
            sound_layout.addWidget(self.sound_path_display)
            sound_layout.addWidget(self.browse_btn)
            sound_layout.addWidget(sound_reset_btn)
            
            # Install event filter to intercept drag and drop events
            self.sound_path_display.setAcceptDrops(True)
            self.sound_path_display.installEventFilter(self)
            
            # Recording sound checkbox (no reset button)
            self.recording_checkbox = QCheckBox("Enable recording sound")
            self.recording_checkbox.setFont(font)
            self.recording_checkbox.setChecked(current_recording_sound)
            self.recording_checkbox.setStyleSheet("""
                QCheckBox {
                    border-style: outset;
                    border-radius: 3px;
                    color: rgb(144, 164, 174);
                }
                QCheckBox::indicator {
                    background-color: rgb(54, 71, 84);
                    border-width: 1px;
                    border-color: rgb(78, 106, 129);
                }
                QCheckBox::indicator:checked {
                    background-color: rgb(20, 89, 134);
                }
            """)
            
            # SRT output checkbox (no reset button)
            self.srt_checkbox = QCheckBox("Output SRT for file transcriptions")
            self.srt_checkbox.setFont(font)
            self.srt_checkbox.setChecked(output_srt)
            self.srt_checkbox.setStyleSheet("""
                QCheckBox {
                    border-style: outset;
                    border-radius: 3px;
                    color: rgb(144, 164, 174);
                }
                QCheckBox::indicator {
                    background-color: rgb(54, 71, 84);
                    border-width: 1px;
                    border-color: rgb(78, 106, 129);
                }
                QCheckBox::indicator:checked {
                    background-color: rgb(20, 89, 134);
                }
            """)
            
            # Add to form layout
            form_layout.addRow(sound_label, sound_widget)
            form_layout.addRow("", self.recording_checkbox)
            form_layout.addRow("", self.srt_checkbox)
            
            # Button area - just keep the reset all button
            button_area = QWidget()
            button_layout = QHBoxLayout(button_area)
            
            # Reset all button
            reset_all_btn = QPushButton("Reset All")
            reset_all_btn.setFixedHeight(button_height)
            reset_all_btn.setIcon(QIcon(resource_path("./media/Command-Reset-256.png")))
            reset_all_btn.setIconSize(QtCore.QSize(16, 16))
            reset_all_btn.setStyleSheet("""
                QPushButton {
                    background-color: rgb(54, 71, 84);
                    color: rgb(144, 164, 174);
                    border: 1px solid rgb(78, 106, 129);
                    border-radius: 3px;
                }
                QPushButton:hover {
                    background-color: rgb(78, 106, 129);
                }
            """)
            reset_all_btn.clicked.connect(self.reset_all)
            
            # Remove OK/Cancel buttons
            button_layout.addWidget(reset_all_btn)
            button_layout.addStretch()
            
            # Assemble layout
            main_layout.addWidget(model_group)
            main_layout.addLayout(form_layout)
            main_layout.addStretch()
            main_layout.addWidget(button_area)
            
            # Set dialog to accept drops
            self.setAcceptDrops(True)
            
            # Connect signals to handle immediate changes
            self.model_combo.currentTextChanged.connect(self.model_changed)
            self.quant_combo.currentTextChanged.connect(self.quantization_changed)
            self.recording_checkbox.toggled.connect(self.recording_sound_changed)
            self.srt_checkbox.toggled.connect(self.srt_output_changed)
        
        def eventFilter(self, obj, event):
            if obj == self.sound_path_display:
                if event.type() == QtCore.QEvent.Type.DragEnter:
                    if event.mimeData().hasUrls():
                        url = event.mimeData().urls()[0].toLocalFile()
                        if os.path.splitext(url)[1].lower() in ['.mp3', '.wav']:
                            event.acceptProposedAction()
                    return True
                elif event.type() == QtCore.QEvent.Type.Drop:
                    if event.mimeData().hasUrls():
                        url = event.mimeData().urls()[0].toLocalFile()
                        if os.path.splitext(url)[1].lower() in ['.mp3', '.wav']:
                            self.current_sound_path = url
                            self.sound_path_display.setText(os.path.basename(url))
                            self.sound_path_display.setToolTip(url)
                    return True
            return super().eventFilter(obj, event)
            
        def dragEnterEvent(self, event):
            mime_data = event.mimeData()

            # Check if the dragged data contains URLs
            if mime_data.hasUrls():
                # Check if any of the URLs are valid audio files
                valid_files = False
                for url in mime_data.urls():
                    file_path = url.toLocalFile()
                    if os.path.splitext(file_path)[1].lower() in ['.mp3', '.wav']:
                        valid_files = True
                        break
                
                if valid_files:
                    # Set the cursor to indicate dropping is allowed
                    self.setCursor(Qt.CursorShape.DragCopyCursor)
                    event.acceptProposedAction()
                else:
                    QMessageBox.warning(self, "Invalid File", "Please drop .mp3 or .wav files.", QMessageBox.StandardButton.Ok)
                    
        def dropEvent(self, event):
            mime_data = event.mimeData()

            # Check if the dragged data contains URLs
            if mime_data.hasUrls():
                # Check if this is from the SettingsDialog (for sound file)
                if event.source() and isinstance(event.source(), SettingsDialog):
                    url = mime_data.urls()[0].toLocalFile()
                    if os.path.splitext(url)[1].lower() in ['.mp3', '.wav']:
                        self.current_sound_path = url
                        
                        # Only set start_sound on listener if recording sound is enabled
                        if self.current_recording_sound and hasattr(self, "listener_worker") and hasattr(self.listener_worker, "listener"):
                            self.listener_worker.listener.start_sound_file = self.current_sound_path
                            self.listener_worker.listener.init_pygame()
                    return
                
                # Otherwise, handle as files for transcription
                file_paths = []
                for url in mime_data.urls():
                    file_path = url.toLocalFile()
                    if os.path.splitext(file_path)[1].lower() in ['.mp3', '.wav']:
                        file_paths.append(file_path)
                
                if file_paths:
                    self.process_audio_files(file_paths)

        def browse_sound_file(self):
            """Handle sound file browsing and apply changes immediately."""
            file_dialog = QFileDialog(self)
            file_dialog.setFileMode(QFileDialog.FileMode.ExistingFile)
            file_dialog.setNameFilter("Audio files (*.mp3 *.wav)")
            file_dialog.setWindowTitle("Select Sound File")
            
            if file_dialog.exec() == QDialog.DialogCode.Accepted:
                selected_file = file_dialog.selectedFiles()[0]
                # Only update if the file changed
                if selected_file != self.current_sound_path:
                    self.current_sound_path = selected_file
                    self.sound_path_display.setText(os.path.basename(selected_file))
                    self.sound_path_display.setToolTip(selected_file)
                    
                    # Apply the change to the parent window
                    if hasattr(self, "parent_window") and self.parent_window:
                        self.parent_window.start_sound = selected_file
                        # Update listener sound if recording sound is enabled
                        if self.current_recording_sound and hasattr(self.parent_window, "listener_worker") and hasattr(self.parent_window.listener_worker, "listener"):
                            self.parent_window.listener_worker.listener.start_sound_file = selected_file
                            self.parent_window.listener_worker.listener.init_pygame()
                        self.parent_window.display_message(txt="Sound file updated")

        def reset_model(self):
            self.model_combo.setCurrentText(self.default_model)
            self.model_changed()
            
        def reset_quantization(self):
            self.quant_combo.setCurrentText(self.default_quantization)
            self.quantization_changed()
            
        def reset_sound_path(self):
            if self.current_sound_path != self.default_sound_path:
                self.current_sound_path = self.default_sound_path
                self.sound_path_display.setText(os.path.basename(self.default_sound_path))
                self.sound_path_display.setToolTip(self.default_sound_path)
                
                # Apply the change to the parent window
                if hasattr(self, "parent_window") and self.parent_window:
                    self.parent_window.start_sound = self.default_sound_path
                    # Update listener sound if recording sound is enabled
                    if self.current_recording_sound and hasattr(self.parent_window, "listener_worker") and hasattr(self.parent_window.listener_worker, "listener"):
                        self.parent_window.listener_worker.listener.start_sound_file = self.default_sound_path
                        self.parent_window.listener_worker.listener.init_pygame()
                    self.parent_window.display_message(txt="Sound file reset to default")
            
        def reset_recording_checkbox(self):
            self.recording_checkbox.setChecked(self.default_recording_sound)
            self.recording_sound_changed()
            
        def reset_srt_checkbox(self):
            self.srt_checkbox.setChecked(self.default_output_srt)
            self.srt_output_changed()
            
        def reset_all(self):
            self.reset_model()
            self.reset_quantization()
            self.reset_sound_path()
            self.reset_recording_checkbox()
            self.reset_srt_checkbox()
            if hasattr(self, "parent_window") and self.parent_window:
                self.parent_window.display_message(txt="All settings reset to defaults")
        
        def get_selected_model(self):
            return self.model_combo.currentText()
        
        def get_selected_quantization(self):
            return self.quant_combo.currentText()
            
        def is_recording_sound_enabled(self):
            return self.recording_checkbox.isChecked()
            
        def is_srt_output_enabled(self):
            return self.srt_checkbox.isChecked()
            
        def get_sound_path(self):
            return self.current_sound_path

        def model_changed(self):
            """Handle model selection changes and apply them immediately."""
            new_model = self.model_combo.currentText()
            # Only update if the value changed
            if new_model != self.current_model:
                self.current_model = new_model
                # Apply the change to the parent window
                if hasattr(self, "parent_window") and self.parent_window:
                    # Check if we need to reinitialize workers
                    if self.parent_window.selected_model != new_model:
                        self.parent_window.selected_model = new_model
                        self.parent_window.init_workers_and_signals()
                        self.parent_window.display_message(txt=f"Model updated to {new_model}")
            
        def quantization_changed(self):
            """Handle quantization selection changes and apply them immediately."""
            new_quantization = self.quant_combo.currentText()
            # Only update if the value changed
            if new_quantization != self.current_quantization:
                self.current_quantization = new_quantization
                # Apply the change to the parent window
                if hasattr(self, "parent_window") and self.parent_window:
                    # Check if we need to reinitialize workers
                    if self.parent_window.selected_quantization != new_quantization:
                        self.parent_window.selected_quantization = new_quantization
                        self.parent_window.init_workers_and_signals()
                        self.parent_window.display_message(txt=f"Quantization updated to {new_quantization}")
            
        def recording_sound_changed(self):
            """Handle recording sound checkbox changes and apply them immediately."""
            new_recording_sound = self.recording_checkbox.isChecked()
            # Only update if the value changed
            if new_recording_sound != self.current_recording_sound:
                self.current_recording_sound = new_recording_sound
                # Apply the change to the parent window
                if hasattr(self, "parent_window") and self.parent_window:
                    self.parent_window.enable_recording_sound = new_recording_sound
                    # Update listener settings
                    if hasattr(self.parent_window, "listener_worker") and hasattr(self.parent_window.listener_worker, "listener"):
                        if new_recording_sound:
                            self.parent_window.listener_worker.listener.start_sound_file = self.current_sound_path
                            self.parent_window.listener_worker.listener.init_pygame()
                        else:
                            self.parent_window.listener_worker.listener.start_sound_file = None
                            self.parent_window.listener_worker.listener.start_sound = None
                    self.parent_window.display_message(txt=f"Recording sound {'enabled' if new_recording_sound else 'disabled'}")
            
        def srt_output_changed(self):
            """Handle SRT output checkbox changes and apply them immediately."""
            new_output_srt = self.srt_checkbox.isChecked()
            # Only update if the value changed
            if new_output_srt != self.current_output_srt:
                self.current_output_srt = new_output_srt
                # Apply the change to the parent window
                if hasattr(self, "parent_window") and self.parent_window:
                    self.parent_window.current_output_srt = new_output_srt
                    self.parent_window.display_message(txt=f"SRT output {'enabled' if new_output_srt else 'disabled'}")
            
        def browse_sound_file(self):
            """Handle sound file browsing and apply changes immediately."""
            file_dialog = QFileDialog(self)
            file_dialog.setFileMode(QFileDialog.FileMode.ExistingFile)
            file_dialog.setNameFilter("Audio files (*.mp3 *.wav)")
            file_dialog.setWindowTitle("Select Sound File")
            
            if file_dialog.exec() == QDialog.DialogCode.Accepted:
                selected_file = file_dialog.selectedFiles()[0]
                # Only update if the file changed
                if selected_file != self.current_sound_path:
                    self.current_sound_path = selected_file
                    self.sound_path_display.setText(os.path.basename(selected_file))
                    self.sound_path_display.setToolTip(selected_file)
                    
                    # Apply the change to the parent window
                    if hasattr(self, "parent_window") and self.parent_window:
                        self.parent_window.start_sound = selected_file
                        # Update listener sound if recording sound is enabled
                        if self.current_recording_sound and hasattr(self.parent_window, "listener_worker") and hasattr(self.parent_window.listener_worker, "listener"):
                            self.parent_window.listener_worker.listener.start_sound_file = selected_file
                            self.parent_window.listener_worker.listener.init_pygame()
                        self.parent_window.display_message(txt="Sound file updated")

    class VadWorker(QObject):
        initialized = pyqtSignal()
        error = pyqtSignal(str)
        
        def __init__(self):
            super().__init__()
            self.status = False

        def run(self):
            try:
                self.vad = VaDetector()
                self.initialized.emit()
                self.toggle_status()
            except Exception as e:
                self.error.emit(f"Failed to initialize VAD: {e}")
                logger.debug(f"Failed to initialize VAD: {e}")
                
        def toggle_status(self):
            self.status = True if self.status==False else False
            
    class ModelWorker(QObject):
        initialized = pyqtSignal()
        error = pyqtSignal(str)
        display_message_signal = pyqtSignal(object, object, object, object, object)# txt=None, filename=None, percentage=None, hold=False, reset=None

        def __init__(self, quantization=None):
            super().__init__()
            self.quantization = quantization
            self.status=False

        def run(self):
            try:
                self.model = WhisperONNXTranscriber(q=self.quantization, display_message_signal=self.display_message_signal)
                self.initialized.emit()
                self.toggle_status()
            except Exception as e:
                self.error.emit(f"Failed to initialize model: {e}")
                logger.debug(f"Failed to initialize model: {e}")
                
        def toggle_status(self):
            self.status = True if self.status==False else False
            
    class ListenerWorker(QObject):
        transcription_ready = pyqtSignal(str)
        error = pyqtSignal(str)
        initialized = pyqtSignal()
        display_message_signal = pyqtSignal(object, object, object, object, object)# txt=None, filename=None, percentage=None, hold=False, reset=None
        terminate_signal = pyqtSignal()
        
        def __init__(self, model, vad, rec_key):
            super().__init__()
            self._running = None
            self.listener = AudioToText(model, vad, error_callback=self.display_message_signal)
            self.rec_key = rec_key

        def run(self,):
            try:
                self.listener.capture_keys(self.rec_key)
                self.initialized.emit()
                self._running = True
                while self._running:
                    QThread.msleep(10)
            except Exception as e:
                self.error.emit(f"Listener Error: {e}")
                logger.debug(f"Listener Error: {e}")
            finally:
                self.listener.shutdown()
                del self.listener
                gc.collect()
        def stop(self):
            self._running = False
            
    class Ui_MainWindow(object):
        def setupUi(self, MainWindow):
            self.script_path = (os.path.dirname(os.path.abspath(__file__)))
            # print(self.script_path)
            self.acc = "CUDAExecutionProvider" in ort.get_available_providers()
            MainWindow.setObjectName("MainWindow")
            MainWindow.setEnabled(True)
            MainWindow.setFixedSize(400, 300)
            
            icon = QIcon(resource_path("./media/Windows 1 Theta.png"))
            MainWindow.setWindowIcon(icon)
            
            sizePolicy = QSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
            sizePolicy.setHorizontalStretch(0)
            sizePolicy.setVerticalStretch(0)
            sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
            MainWindow.setSizePolicy(sizePolicy)
            palette = QtGui.QPalette()
            brush = QtGui.QBrush(QtGui.QColor(46, 52, 64))
            brush.setStyle(Qt.BrushStyle.SolidPattern)
            palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Base, brush)
            brush = QtGui.QBrush(QtGui.QColor(20, 27, 31))
            brush.setStyle(Qt.BrushStyle.SolidPattern)
            palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Window, brush)
            brush = QtGui.QBrush(QtGui.QColor(46, 52, 64))
            brush.setStyle(Qt.BrushStyle.SolidPattern)
            palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Base, brush)
            brush = QtGui.QBrush(QtGui.QColor(20, 27, 31))
            brush.setStyle(Qt.BrushStyle.SolidPattern)
            palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Window, brush)
            brush = QtGui.QBrush(QtGui.QColor(20, 27, 31))
            brush.setStyle(Qt.BrushStyle.SolidPattern)
            palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Base, brush)
            brush = QtGui.QBrush(QtGui.QColor(20, 27, 31))
            brush.setStyle(Qt.BrushStyle.SolidPattern)
            palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Window, brush)
            MainWindow.setPalette(palette)
            self.centralwidget = QWidget(parent=MainWindow)
            self.centralwidget.setEnabled(True)
            sizePolicy = QSizePolicy(QSizePolicy.Policy.Fixed, QSizePolicy.Policy.Fixed)
            sizePolicy.setHorizontalStretch(0)
            sizePolicy.setVerticalStretch(0)
            sizePolicy.setHeightForWidth(self.centralwidget.sizePolicy().hasHeightForWidth())
            self.centralwidget.setSizePolicy(sizePolicy)
            self.centralwidget.setObjectName("centralwidget")
            self.line = QFrame(parent=self.centralwidget)
            self.line.setStyleSheet("color: rgb(144, 164, 174);")
            self.line.setGeometry(QtCore.QRect(80, 190, 241, 20))
            self.line.setFrameShape(QFrame.Shape.HLine)
            self.line.setFrameShadow(QFrame.Shadow.Sunken)
            self.line.setObjectName("line")
            
            # Removed checkBox
            
            self.label = QLabel(parent=self.centralwidget)
            self.label.setGeometry(QtCore.QRect(262, 269, 161, 31))
            self.label.setStyleSheet("""QLabel {
                                        color: rgb(144, 164, 174);
                                    }
                                    """)
            font = QtGui.QFont()
            font.setFamily("Roboto")
            self.label.setFont(font)
            self.label.setObjectName("label")
            self.WinSTT = QLabel(parent=self.centralwidget)
            self.WinSTT.setStyleSheet("""QLabel {
                                        color: rgb(144, 164, 174);
                                    }
                                    """)
            self.WinSTT.setGeometry(QtCore.QRect(150, 10, 131, 31))
            font = QtGui.QFont()
            font.setFamily("Codec Pro ExtraBold")
            font.setPointSize(24)
            font.setBold(True)
            font.setWeight(75)
            self.WinSTT.setFont(font)
            self.WinSTT.setMouseTracking(True)
            self.WinSTT.setTextFormat(QtCore.Qt.TextFormat.PlainText)
            self.WinSTT.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
            self.WinSTT.setObjectName("WinSTT")
            self.label_3 = QLabel(parent=self.centralwidget)
            self.label_3.setStyleSheet("color: rgb(144, 164, 174);")
            self.label_3.setGeometry(QtCore.QRect(17, 200, 370, 50))
            self.label_3.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
            font = QtGui.QFont()
            font.setFamily("Input")
            font.setPointSize(10)
            self.label_3.setFont(font)
            self.label_3.setObjectName("label_3")
            self.progressBar = QProgressBar(parent=self.centralwidget)
            self.progressBar.setGeometry(QtCore.QRect(60, 240, 290, 14))
            self.progressBar.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
            self.progressBar.setStyleSheet("""
                                                QProgressBar {background-color: rgb(8, 11, 14);
                                                color: rgb(144, 164, 174);
                                                border-radius: 5px}
                                                """)
            font = QtGui.QFont()
            font.setFamily("Input")
            self.progressBar.setFont(font)
            self.progressBar.setProperty("value", 0)
            self.progressBar.setObjectName("progressBar")
            self.progressBar.setVisible(False)
            self.graphicsView_2 = QGraphicsView(parent=self.centralwidget)
            self.graphicsView_2.setGeometry(QtCore.QRect(0, 270, 411, 31))
            palette = QtGui.QPalette()
            brush = QtGui.QBrush(QtGui.QColor(8, 11, 14))
            brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
            palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Base, brush)
            brush = QtGui.QBrush(QtGui.QColor(8, 11, 14))
            brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
            palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Base, brush)
            brush = QtGui.QBrush(QtGui.QColor(20, 27, 31))
            brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
            palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Base, brush)
            self.graphicsView_2.setPalette(palette)
            self.graphicsView_2.setObjectName("graphicsView_2")
            self.label_2 = QLabel(parent=self.centralwidget)
            self.label_2.setGeometry(QtCore.QRect(160, 10, 21, 21))
            self.label_2.setText("")
            self.label_2.setPixmap(QtGui.QPixmap(resource_path("./media/Windows 1 Theta.png")))
            self.label_2.setScaledContents(True)
            self.label_2.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
            self.label_2.setObjectName("label_2")
            self.pushButton = QPushButton(parent=self.centralwidget)
            self.pushButton.setGeometry(QtCore.QRect(230, 70, 101, 22))
            self.pushButton.setFixedHeight(22)
            self.pushButton.setObjectName("pushButton")
            self.pushButton.setStyleSheet("QPushButton {background-color: rgb(54, 71, 84); color: rgb(144, 164, 174); border-style: outset;  border-radius: 3px; border-width: 1px; border-color: rgb(78, 106, 129)}")

            self.textEdit = QTextEdit(parent=self.centralwidget)
            self.textEdit.setGeometry(QtCore.QRect(70, 70, 110, 22))
            self.textEdit.setFixedHeight(22)
            self.textEdit.setLineWidth(0)
            self.textEdit.setText('CTRL+ALT+A')
            self.textEdit.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
            self.textEdit.setReadOnly(True)
            self.textEdit.setObjectName("Current Key")
            self.textEdit.setStyleSheet("""
                                        QTextEdit {background-color: rgb(54, 71, 84);
                                        color: rgb(144, 164, 174); border-style: outset;
                                        border-radius: 3px; border-width: 1px;
                                        border-color: rgb(78, 106, 129)}
                                        """)
            
            self.label_4 = QLabel(parent=self.centralwidget)
            self.label_4.setGeometry(QtCore.QRect(360, 270, 31, 31))
            self.label_4.setText("")
            self.label_4.setPixmap(QtGui.QPixmap(resource_path("./media/switch-on.png") if self.acc else resource_path("./media/switch-off.png")))
            self.label_4.setScaledContents(True)
            self.label_4.setObjectName("label_4")
            self.label_5 = QLabel(parent=self.centralwidget)
            self.label_5.setGeometry(QtCore.QRect(0, -5, 401, 51))
            self.label_5.setText("")
            self.label_5.setPixmap(QtGui.QPixmap(resource_path("./media/Untitled-1.png")))
            self.label_5.setScaledContents(True)
            self.label_5.setObjectName("label_5")
            self.label_5.raise_()
            self.graphicsView_2.raise_()
            self.line.raise_()
            # self.checkBox.raise_() - removed
            self.label.raise_()
            self.WinSTT.raise_()
            self.label_3.raise_()
            self.progressBar.raise_()
            self.label_2.raise_()
            self.pushButton.raise_()
            self.textEdit.raise_()
            # Remove raising combo boxes
            self.label_4.raise_()
            MainWindow.setCentralWidget(self.centralwidget)
            self.retranslateUi(MainWindow)

        def retranslateUi(self, MainWindow):
            _translate = QtCore.QCoreApplication.translate
            MainWindow.setWindowTitle(_translate("MainWindow", "WinSTT"))
            # self.checkBox.setText(_translate("MainWindow", "Recording sound (Drag/Drop)")) - removed
            # self.checkBox.setChecked(True) - removed
            self.label.setText(_translate("MainWindow", "H/W Acceleration:"))
            self.WinSTT.setText(_translate("MainWindow", "STT"))
            self.label_3.setText(_translate("MainWindow", ""))
            self.pushButton.setText(_translate("MainWindow", "Change Rec Key"))
                
    class Window(QMainWindow, Ui_MainWindow):
        def __init__(self):
            super().__init__()
            self.setupUi(self)
            
            # Enable drag and drop for the main window
            self.setAcceptDrops(True)
            
            self.start_sound = os.path.join(resource_path("./media/splash.mp3"))
            self.enable_recording_sound = True  # Default to enabled
            self.current_output_srt = False  # Default to no SRT output
            self.pressed_keys = set()
            self.record_key_toggle = False
            self.toolbar_visible = False  # Track toolbar visibility state
            self.toolbar_persistent = False  # New property for persistent toolbar
            self.current_menu = None  # Track the currently open menu
            self.button_menu_map = {}  # Map buttons to their menus
            self.is_transcribing = False  # Flag to track if transcription is in progress
            self.transcription_queue = []  # Queue for multiple file transcription
            
            # Set consistent button height
            button_height = 22  # Standard button height for main window
            
            # Dynamically determine the MouseButtonPress event type
            try:
                self.MOUSE_PRESS = QtCore.QEvent.MouseButtonPress  # PyQt5
            except AttributeError:
                self.MOUSE_PRESS = QtCore.QEvent.Type.MouseButtonPress  # PyQt6
            
            self.pushButton.clicked.connect(self.toggle_and_set)
                    
            self.minimize_counter = 0
            
            # Set initial settings
            self.selected_model = "Whisper-Turbo"
            self.selected_quantization = "Full" if self.acc else "Quantized"

            # Initialize threads
            self.vad_thread = QThread()
            self.model_thread = QThread()
            self.listener_thread = QThread()
            self.started_listener = False
            
            # Initialize actions for menus
            self.show_action = QAction("Show", self)
            self.settings_action = QAction("Settings", self)
            self.open_action = QAction("Open...", self)
            self.close_action = QAction("Exit", self)
            self.persistent_toolbar_action = QAction("Persistent Toolbar", self)
            self.persistent_toolbar_action.setCheckable(True)
            self.persistent_toolbar_action.setChecked(self.toolbar_persistent)
            
            # Connect settings action
            self.settings_action.triggered.connect(self.open_settings)
            # Connect open action
            self.open_action.triggered.connect(self.open_files)
            # Connect close action
            self.close_action.triggered.connect(self.close_app)
            # Connect persistent toolbar action
            self.persistent_toolbar_action.triggered.connect(self.toggle_persistent_toolbar)
            
            # Initialize workers and signals
            self.init_workers_and_signals()

            # Create the custom toolbar widget that overlays UI
            self.create_toolbar()
            self.toolbar_widget.hide()  # Hide initially
            
            # Create tray icon
            self.tray_icon = QSystemTrayIcon(self)
            self.create_tray_icon()
            
            # Explicitly set central widget geometry to cover the entire window
            self.centralwidget.setGeometry(0, 0, self.width(), self.height())
            
            self.logger = setup_logger()      
            
            # Install the event filter (if not already done)
            QApplication.instance().installEventFilter(self)
            
        def open_settings(self):
            """Open the settings dialog. Settings changes are applied immediately."""
            dialog = SettingsDialog(self.selected_model, self.selected_quantization, self.enable_recording_sound, self.start_sound, self.current_output_srt, self.acc, self)
            # Show the dialog - no need to check for accept/reject as changes are applied immediately
            dialog.exec()

        def init_workers_and_signals(self):
            # Initialize VAD worker and thread
            if not hasattr(self, "vad_worker"):
                self.vad_worker = VadWorker()
                self.vad_worker.moveToThread(self.vad_thread)
                self.vad_worker.initialized.connect(lambda: self.display_message(txt="VAD Initialized"))
                self.vad_worker.initialized.connect(lambda: self.init_listener())
                self.vad_worker.error.connect(lambda error_message: self.display_message(txt=f"Error: {error_message}"))
                self.vad_thread.started.connect(self.vad_worker.run)
                self.vad_thread.start()

            # Initialize Model worker and thread
            if hasattr(self, "model_worker"):
                self.model_thread.quit()
                self.model_thread.wait()
                self.model_worker.model.clear_sessions()
                self.model_worker.deleteLater()
                self.model_thread.deleteLater()
                self.model_thread = QThread()
            self.model_worker = ModelWorker(self.selected_quantization)  # Use selected_quantization
            self.model_worker.moveToThread(self.model_thread)
            self.model_worker.display_message_signal.connect(lambda txt, filename, percentage, hold, reset: self.display_message(txt, filename, percentage, hold, reset))
            self.model_worker.initialized.connect(lambda: self.display_message(txt="Model Initialized"))
            self.model_worker.initialized.connect(lambda: self.init_listener())
            self.model_worker.error.connect(lambda error_message: self.display_message(txt=f"Error: {error_message}"))
            self.model_thread.started.connect(self.model_worker.run)
            self.model_thread.start()
            
        def init_listener(self):
            # Initialize Listener worker and thread
            if hasattr(self, "model_worker") and hasattr(self.model_worker, "model") and hasattr(self, "vad_worker") and hasattr(self.vad_worker, "vad"):
                if not self.started_listener:
                    self.started_listener = True
                elif hasattr(self, "listener_worker"):
                    self.listener_worker.stop()
                    self.listener_thread.quit()
                    self.listener_thread.wait()
                    self.listener_worker.deleteLater()
                    self.listener_thread.deleteLater()
                    gc.collect()
                    self.listener_thread = QThread()
                self.listener_worker = ListenerWorker(self.model_worker.model, self.vad_worker.vad, self.textEdit.toPlainText())
                self.listener_worker.moveToThread(self.listener_thread)
                self.listener_worker.transcription_ready.connect(self.handle_transcription)
                self.listener_worker.error.connect(lambda error_message: self.display_message(txt=f"Error: {error_message}"))
                self.listener_worker.initialized.connect(lambda: self.display_message(txt="Listener Initialized"))
                self.listener_worker.display_message_signal.connect(lambda txt, filename, percentage, hold, reset: self.display_message(txt, filename, percentage, hold, reset))
                self.listener_thread.started.connect(self.listener_worker.run)
                self.listener_thread.start()
                
                # Set initial start_sound based on enable_recording_sound
                if self.enable_recording_sound and hasattr(self.listener_worker, "listener"):
                    self.listener_worker.listener.start_sound_file = self.start_sound
                    self.listener_worker.listener.init_pygame()
                else:
                    if hasattr(self.listener_worker, "listener"):
                        self.listener_worker.listener.start_sound_file = None
                        self.listener_worker.listener.start_sound = None

        def handle_transcription(self, transcription):
            self.display_message(txt=f"{transcription}")
            
        def show_notification(self):
            self.minimize_counter +=1
        # Only show notification when the window is minimized the first time
            if self.minimize_counter == 1:
                self.tray_icon.showMessage(
                    "App Minimized",
                    "The app is minimized, and still running in the background. Right click on icon to exit",
                    QSystemTrayIcon.MessageIcon.Information,
                    2000
                ) 

        def open_files(self):
            """Open file dialog to select audio files for transcription."""
            file_dialog = QFileDialog(self)
            file_dialog.setFileMode(QFileDialog.FileMode.ExistingFiles)
            file_dialog.setNameFilter("Audio files (*.mp3 *.wav)")
            file_dialog.setWindowTitle("Select Audio Files to Transcribe")
            
            if file_dialog.exec() == QDialog.DialogCode.Accepted:
                selected_files = file_dialog.selectedFiles()
                if selected_files:
                    self.process_audio_files(selected_files)

        def process_audio_files(self, file_paths):
            """Process a list of audio files for transcription."""
            # Check if the model is initialized
            if not hasattr(self, "model_worker") or not hasattr(self.model_worker, "model"):
                self.display_message(txt="Model not initialized. Please wait and try again.")
                return
            
            # Add files to the transcription queue
            for file_path in file_paths:
                if os.path.splitext(file_path)[1].lower() in ['.mp3', '.wav']:
                    self.transcription_queue.append(file_path)
            
            # Start processing if not already in progress
            if not self.is_transcribing and self.transcription_queue:
                # Pause the listener to free the mic
                self.pause_listener()
                self.process_next_file()
                
        def pause_listener(self):
            """Pause the listener worker to free the microphone."""
            if hasattr(self, "listener_worker") and hasattr(self.listener_worker, "listener"):
                logger.debug("Pausing listener for file transcription")
                try:
                    # Stop the audio stream in the listener
                    if hasattr(self.listener_worker.listener, "stream") and self.listener_worker.listener.stream:
                        self.listener_worker.listener.stream.stop_stream()
                        logger.debug("Audio stream stopped")
                except Exception as e:
                    logger.error(f"Error pausing listener: {str(e)}")
                    
        def resume_listener(self):
            """Resume the listener worker after file transcription."""
            if hasattr(self, "listener_worker") and hasattr(self.listener_worker, "listener"):
                try:
                    # Restart the audio stream if needed
                    if hasattr(self.listener_worker.listener, "stream") and self.listener_worker.listener.stream:
                        if not self.listener_worker.listener.stream.is_active():
                            self.listener_worker.listener.stream.start_stream()
                            logger.debug("Audio stream restarted")
                except Exception as e:
                    logger.error(f"Error resuming listener: {str(e)}")
                    
                    # If we can't resume, try to reinitialize
                    try:
                        logger.debug("Reinitializing listener")
                        self.init_listener()
                    except Exception as e2:
                        logger.error(f"Error reinitializing listener: {str(e2)}")
            
        def process_next_file(self):
            """Process the next file in the transcription queue."""
            if not self.transcription_queue:
                self.is_transcribing = False
                return
            
            # Get the next file
            file_path = self.transcription_queue[0]
            self.transcription_queue.pop(0)
            
            # Transcribe the file
            self.transcribe_file(file_path)
            
        def dragEnterEvent(self, event):
            mime_data = event.mimeData()

            # Check if the dragged data contains URLs
            if mime_data.hasUrls():
                # Check if any of the URLs are valid audio files
                valid_files = False
                for url in mime_data.urls():
                    file_path = url.toLocalFile()
                    if os.path.splitext(file_path)[1].lower() in ['.mp3', '.wav']:
                        valid_files = True
                        break
                
                if valid_files:
                    # Set the cursor to indicate dropping is allowed
                    self.setCursor(Qt.CursorShape.DragCopyCursor)
                    event.acceptProposedAction()
                else:
                    QMessageBox.warning(self, "Invalid File", "Please drop .mp3 or .wav files.", QMessageBox.StandardButton.Ok)
                    
        def dragLeaveEvent(self, event):
            # Reset cursor when drag leaves the window
            self.setCursor(Qt.CursorShape.ArrowCursor)
            event.accept()
                
        def dropEvent(self, event):
            # Reset cursor
            self.setCursor(Qt.CursorShape.ArrowCursor)
            
            mime_data = event.mimeData()

            # Check if the dragged data contains URLs
            if mime_data.hasUrls():
                # Check if this is from the SettingsDialog (for sound file)
                if event.source() and isinstance(event.source(), SettingsDialog):
                    url = mime_data.urls()[0].toLocalFile()
                    if os.path.splitext(url)[1].lower() in ['.mp3', '.wav']:
                        self.start_sound = url
                        
                        # Only set start_sound on listener if recording sound is enabled
                        if self.enable_recording_sound and hasattr(self, "listener_worker") and hasattr(self.listener_worker, "listener"):
                            self.listener_worker.listener.start_sound_file = self.start_sound
                            self.listener_worker.listener.init_pygame()
                    return
                
                # Otherwise, handle as files for transcription
                file_paths = []
                for url in mime_data.urls():
                    file_path = url.toLocalFile()
                    if os.path.splitext(file_path)[1].lower() in ['.mp3', '.wav']:
                        file_paths.append(file_path)
                
                if file_paths:
                    self.process_audio_files(file_paths)

        def transcribe_file(self, file_path):
            """Transcribe an audio file and save the transcription to a file."""
            # Check if the model is initialized
            if not hasattr(self, "model_worker") or not hasattr(self.model_worker, "model"):
                self.display_message(txt="Model not initialized. Please wait and try again.")
                self.process_next_file()  # Try the next file
                return
                
            try:
                # Set the flag to indicate transcription in progress
                self.is_transcribing = True
                
                # Check if file exists
                if not os.path.exists(file_path):
                    raise FileNotFoundError(f"File not found: {file_path}")
                
                # Log the transcription attempt
                logger.debug(f"Starting transcription of file: {file_path}")
                
                # Disable buttons during transcription
                self.pushButton.setEnabled(False)
                self.textEdit.setEnabled(False)
                
                # Show message but don't show progress bar
                self.display_message(txt=f"Transcribing {os.path.basename(file_path)}...", hold=True)
                
                # Create a separate thread for transcription
                class TranscriptionThread(QThread):
                    transcription_complete = pyqtSignal(str, str, list)  # (output_path, transcription, segments)
                    transcription_error = pyqtSignal(str)
                    
                    def __init__(self, model, file_path, output_srt):
                        super().__init__()
                        self.model = model
                        self.file_path = file_path
                        self.output_srt = output_srt
                        
                    def run(self):
                        try:
                            # Get the transcription with timestamps if available
                            result = self.model.transcribe(self.file_path)
                            logger.debug(f"Transcription complete with result length: {len(result) if result else 0}")
                            
                            # Get segments with timestamps if available
                            segments = []
                            if self.output_srt:
                                try:
                                    # Try to get segments with timestamps (will depend on the model implementation)
                                    segments = self.model.get_segments()
                                    logger.debug(f"Retrieved {len(segments)} segments with timestamps")
                                except Exception as e:
                                    logger.warning(f"Could not retrieve segments with timestamps: {str(e)}")
                            
                            # Save either SRT or TXT based on settings
                            if self.output_srt and segments:
                                # Save as SRT file
                                srt_path = os.path.splitext(self.file_path)[0] + ".srt"
                                logger.debug(f"Saving SRT to {srt_path}")
                                self.save_as_srt(segments, srt_path)
                                output_path = srt_path
                            else:
                                # Save as TXT file
                                output_path = os.path.splitext(self.file_path)[0] + ".txt"
                                logger.debug(f"Saving transcription to {output_path}")
                                with open(output_path, 'w', encoding='utf-8') as f:
                                    f.write(result)
                                
                            self.transcription_complete.emit(output_path, result, segments)
                        except Exception as e:
                            logger.error(f"Transcription error: {str(e)}")
                            self.transcription_error.emit(str(e))
                    
                    def save_as_srt(self, segments, srt_path):
                        """Save segments as an SRT file."""
                        try:
                            with open(srt_path, 'w', encoding='utf-8') as f:
                                for i, segment in enumerate(segments):
                                    # Extract start and end times in seconds
                                    start_time = segment.get('start', 0)
                                    end_time = segment.get('end', 0)
                                    text = segment.get('text', '')
                                    
                                    # Format times as SRT format: HH:MM:SS,mmm
                                    start_formatted = self.format_time(start_time)
                                    end_formatted = self.format_time(end_time)
                                    
                                    # Write SRT entry
                                    f.write(f"{i+1}\n")
                                    f.write(f"{start_formatted} --> {end_formatted}\n")
                                    f.write(f"{text.strip()}\n\n")
                            
                            logger.debug(f"Successfully saved SRT file to {srt_path}")
                        except Exception as e:
                            logger.error(f"Error saving SRT file: {str(e)}")
                            
                    def format_time(self, time_seconds):
                        """Format time in seconds to SRT format: HH:MM:SS,mmm."""
                        hours = int(time_seconds // 3600)
                        minutes = int((time_seconds % 3600) // 60)
                        seconds = int(time_seconds % 60)
                        milliseconds = int((time_seconds - int(time_seconds)) * 1000)
                        
                        return f"{hours:02d}:{minutes:02d}:{seconds:02d},{milliseconds:03d}"
                
                # Create and start the transcription thread
                self.transcription_thread = TranscriptionThread(self.model_worker.model, file_path, self.current_output_srt)
                
                # Connect signals
                self.transcription_thread.transcription_complete.connect(self.transcription_finished)
                self.transcription_thread.transcription_error.connect(self.transcription_error)
                
                # Start the thread
                logger.debug("Starting transcription thread")
                self.transcription_thread.start()
                
            except Exception as e:
                logger.error(f"Error setting up transcription: {str(e)}")
                self.display_message(txt=f"Error: {str(e)}")
                self.is_transcribing = False
                self.pushButton.setEnabled(True)
                self.textEdit.setEnabled(True)
                self.process_next_file()  # Try next file if any
            
        def transcription_finished(self, output_path, transcription, segments):
            """Called when transcription is complete."""
            try:
                # Log success
                logger.debug(f"Transcription finished successfully: {output_path}")
                
                # Determine message to display
                if self.current_output_srt and segments:
                    message = f"Transcription complete. Saved to {os.path.basename(output_path)}"
                else:
                    message = f"Transcription complete. Saved to {os.path.basename(output_path)}"
                
                # Show completion message
                self.display_message(txt=message, reset=True)
                
                # Process the next file if any
                if self.transcription_queue:
                    self.process_next_file()
                else:
                    # Re-enable buttons if no more files to process
                    self.is_transcribing = False
                    self.pushButton.setEnabled(True)
                    self.textEdit.setEnabled(True)
                    
                    # Resume the listener since we're done with transcription
                    self.resume_listener()
            except Exception as e:
                logger.error(f"Error in transcription_finished: {str(e)}")
                self.is_transcribing = False
                self.pushButton.setEnabled(True)
                self.textEdit.setEnabled(True)
                
                # Always try to resume the listener even if there's an error
                self.resume_listener()
            
        def transcription_error(self, error_message):
            """Called when transcription encounters an error."""
            logger.error(f"Transcription error: {error_message}")
            
            # Display the error to the user
            self.display_message(txt=f"Error: {error_message}", reset=True)
            
            # Re-enable buttons
            self.pushButton.setEnabled(True)
            self.textEdit.setEnabled(True)
            
            # Reset transcription flag
            self.is_transcribing = False
            
            # Resume the listener for microphone input
            self.resume_listener()
            
            # Try the next file if any
            if self.transcription_queue:
                self.process_next_file()
            else:
                self.display_message(txt="Transcription completed with errors.")
                
        def keyReleaseEvent(self, event):
            if self.record_key_toggle:
                event.accept()
                self.textEdit.setReadOnly(False)
                key_text = self.get_key_name(event)
                self.pressed_keys.discard(key_text)
                if len(self.pressed_keys)>0:
                    self.combination = "+".join(sorted(self.pressed_keys))
                    self.textEdit.setText(self.combination)    
                                
                self.textEdit.setReadOnly(True)
                self.textEdit.setAlignment(Qt.AlignmentFlag.AlignCenter)
            super().keyReleaseEvent(event)
                
        def get_key_name(self, event: QtGui.QKeyEvent):
            """Return the name of the key."""
            key = event.key()
            
            # Handle modifier keys
            if key == Qt.Key.Key_Control:
                return "Ctrl"
            elif key == Qt.Key.Key_Alt:
                return "Alt"
            elif key == Qt.Key.Key_Shift:
                return "Shift"
            elif key == Qt.Key.Key_Meta:
                return "Meta"
            else:
                # Handle regular keys using key()
                key_text = QtGui.QKeySequence(key).toString()
                if key_text:
                    return key_text
                return f"Key_{key}"
            
        def changeEvent(self, event):
            if event.type() == QtCore.QEvent.Type.WindowStateChange:
                if self.windowState() == Qt.WindowState.WindowMinimized:
                    self.minimize_counter+=1
                    # Hide the window and remove from taskbar
                    self.hide()
                    # Show a tray notification
                    if self.minimize_counter ==1:
                        self.tray_icon.showMessage(
                            "App Minimized",
                            "The app is minimized to the system tray and running in the background. Right-click the tray icon to restore or exit.",
                            QSystemTrayIcon.MessageIcon.Information,
                            3000
                        )
                elif event.oldState() & Qt.WindowState.WindowMinimized:
                    # Restore the window and show it in the taskbar
                    self.show()
                super().changeEvent(event)
                
        def create_toolbar(self):
            # Create a QWidget as the toolbar
            self.toolbar_widget = QWidget(self)
            self.toolbar_widget.setGeometry(0, 0, self.width(), 22)  # Reduced height from 30 to 22
            self.toolbar_widget.setStyleSheet("""
                background-color: rgb(54, 71, 84);
                border-bottom: 1px solid rgb(78, 106, 129);
            """)
            layout = QHBoxLayout(self.toolbar_widget)
            layout.setContentsMargins(8, 0, 8, 0)  # Increased left/right padding
            layout.setSpacing(15)  # Add space between buttons
            
            # File button and menu
            file_button = QPushButton("File", self.toolbar_widget)
            file_button.setStyleSheet("""
                color: rgb(144, 164, 174);
                background-color: transparent;
                border: none;
                padding: 2px 8px;
            """)
            file_menu = QMenu(self)
            file_menu.addAction(self.open_action)
            file_menu.addAction(self.close_action)
            file_button.clicked.connect(lambda: self.open_menu(file_button))
            # Install event filter on button for hover behavior
            file_button.installEventFilter(self)
            layout.addWidget(file_button)
            
            # Options button and menu
            options_button = QPushButton("Options", self.toolbar_widget)
            options_button.setStyleSheet("""
                color: rgb(144, 164, 174);
                background-color: transparent;
                border: none;
                padding: 2px 8px;
            """)
            options_menu = QMenu(self)
            options_menu.addAction(self.settings_action)
            options_menu.addAction(self.persistent_toolbar_action)
            options_button.clicked.connect(lambda: self.open_menu(options_button))
            # Install event filter on button for hover behavior
            options_button.installEventFilter(self)
            layout.addWidget(options_button)
            
            # Map buttons to menus
            self.button_menu_map = {
                file_button: file_menu,
                options_button: options_menu
            }
            
            # Add spacer to push buttons to the left
            layout.addStretch(1)
            
            # Style the menus
            file_menu.setStyleSheet("""
                QMenu {
                    background-color: rgb(54, 71, 84);
                    color: rgb(144, 164, 174);
                    border: 1px solid rgb(78, 106, 129);
                }
                QMenu::item:selected {
                    background-color: rgb(78, 106, 129);
                }
            """)
            options_menu.setStyleSheet("""
                QMenu {
                    background-color: rgb(54, 71, 84);
                    color: rgb(144, 164, 174);
                    border: 1px solid rgb(78, 106, 129);
                }
                QMenu::item:selected {
                    background-color: rgb(78, 106, 129);
                }
            """)
            
            # Ensure the toolbar stays on top
            self.toolbar_widget.raise_()
            
        def open_menu(self, button):
            """Open or switch menus when a button is clicked."""
            menu = self.button_menu_map[button]
            if self.current_menu == menu:
                # If clicking the same button, close the menu
                menu.close()
                self.current_menu = None
            else:
                # Close any existing menu and open the new one
                if self.current_menu:
                    self.current_menu.close()
                pos = button.mapToGlobal(QtCore.QPoint(0, button.height()))
                menu.popup(pos)  # Use popup() for non-blocking behavior
                self.current_menu = menu
            
        def resizeEvent(self, event):
            """Handle window resizing to maintain widget positions."""
            super().resizeEvent(event)
            
            # Adjust toolbar to span the top
            self.toolbar_widget.setGeometry(0, 0, self.width(), 22)
            
            # Adjust central widget based on toolbar persistence
            if self.toolbar_persistent:
                self.centralwidget.setGeometry(0, self.toolbar_widget.height(), 
                                               self.width(), 
                                               self.height() - self.toolbar_widget.height())
            else:
                # Set central widget to cover the entire window
                self.centralwidget.setGeometry(0, 0, self.width(), self.height())
            
            # Ensure toolbar stays on top
            if self.toolbar_visible or self.toolbar_persistent:
                self.toolbar_widget.raise_()
                
        def keyPressEvent(self, event):
            if self.record_key_toggle:
                event.accept()
                self.textEdit.setReadOnly(False)
                key_text = self.get_key_name(event)
                self.pressed_keys.add(key_text)
                self.combination = "+".join(sorted(self.pressed_keys))
                self.textEdit.setText(self.combination)
                self.textEdit.setReadOnly(True)
                self.textEdit.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
            elif event.key() == Qt.Key.Key_Alt and not event.isAutoRepeat() and not self.toolbar_persistent:
                # Toggle toolbar visibility when Alt is pressed (not repeated)
                # but only if toolbar is not persistent
                self.toolbar_visible = not self.toolbar_visible
                if self.toolbar_visible:
                    self.toolbar_widget.show()
                    self.toolbar_widget.raise_()  # Bring to front
                else:
                    self.toolbar_widget.hide()
                    if self.current_menu:
                        self.current_menu.close()
                        self.current_menu = None
            super().keyPressEvent(event)
                
        def eventFilter(self, obj, event):
            """Handle mouse clicks and hover events."""
            if event.type() == self.MOUSE_PRESS and self.toolbar_visible and not self.toolbar_persistent:
                # Check if the click is outside the toolbar
                # but only hide if toolbar is not persistent
                try:
                    click_pos = event.globalPos()  # PyQt5
                except AttributeError:
                    click_pos = event.globalPosition().toPoint()  # PyQt6
                
                toolbar_rect = self.toolbar_widget.geometry()
                toolbar_global_rect = QtCore.QRect(
                    self.mapToGlobal(toolbar_rect.topLeft()),
                    self.mapToGlobal(toolbar_rect.bottomRight())
                )
                if not toolbar_global_rect.contains(click_pos):
                    # Check if the click is not on a menu
                    active_popup = QApplication.activePopupWidget()
                    if not (active_popup and active_popup.geometry().contains(click_pos)):
                        self.toolbar_widget.hide()
                        self.toolbar_visible = False
                        if self.current_menu:
                            self.current_menu.close()
                            self.current_menu = None
            elif (event.type() == QtCore.QEvent.Type.Enter and 
                  obj in self.button_menu_map and 
                  self.toolbar_visible and 
                  self.current_menu):
                # If a menu is open and mouse enters another button, switch menus
                current_button = None
                for button, menu in self.button_menu_map.items():
                    if menu == self.current_menu:
                        current_button = button
                        break
                
                if current_button != obj:  # Only switch if hovering a different button
                    self.current_menu.close()
                    menu = self.button_menu_map[obj]
                    pos = obj.mapToGlobal(QtCore.QPoint(0, obj.height()))
                    menu.popup(pos)
                    self.current_menu = menu
            return super().eventFilter(obj, event)
        
        def hide_toolbar(self):
            """Hide the toolbar when a menu is closed."""
            if not self.toolbar_persistent:
                self.toolbar_widget.hide()
                self.toolbar_visible = False
        
        def create_tray_icon(self):
            self.tray_icon.setIcon(QIcon(resource_path("./media/Windows 1 Theta.png")))

            self.show_action.triggered.connect(self.show_window)
            self.close_action.triggered.connect(self.close_app)
            tray_menu = QMenu()
            tray_menu.addAction(self.settings_action)
            tray_menu.addAction(self.close_action)
            
            self.tray_icon.setContextMenu(tray_menu)
            self.tray_icon.setVisible(True)
            self.tray_icon.show()
            self.tray_icon.activated.connect(self.tray_icon_activated)
            
        def show_window(self):
            self.showNormal()
            self.activateWindow()
            
        def close_app(self):
            self.tray_icon.hide()
            QtCore.QCoreApplication.quit()
            
        def tray_icon_activated(self, reason):
            if reason == QSystemTrayIcon.ActivationReason.DoubleClick:
                self.show_window()
                
        def toggle_and_set(self):
            # Define styles
            normal_style = """
                QTextEdit {
                    background-color: rgb(54, 71, 84);
                    color: rgb(144, 164, 174);
                    border-style: outset;
                    border-radius: 3px;
                    border-width: 1px;
                    border-color: rgb(78, 106, 129)
                }
            """
            editing_style = """
                QTextEdit {
                    background-color: rgb(80, 40, 40);  /* Dark reddish color */
                    color: rgb(144, 164, 174);
                    border-style: outset;
                    border-radius: 3px;
                    border-width: 1px;
                    border-color: rgb(78, 106, 129)
                }
            """

            if not self.record_key_toggle:
                self.record_key_toggle = True
                self.pushButton.setText("Stop")
                self.textEdit.setStyleSheet(editing_style)
            else:
                self.record_key_toggle = False
                if len(self.textEdit.toPlainText()) > 0:
                    self.listener_worker.listener.capture_keys(self.textEdit.toPlainText().lower())
                
                self.pressed_keys = set()
                self.pushButton.setText("Record Key")
                self.textEdit.setStyleSheet(normal_style)
                
        def display_message(self, txt=None, filename=None, percentage=None, hold=None, reset=None):
            # Create opacity effects if they don't exist
            if not hasattr(self, 'label_opacity_effect'):
                self.label_opacity_effect = QGraphicsOpacityEffect(self.label_3)
                self.label_3.setGraphicsEffect(self.label_opacity_effect)
            
            if not hasattr(self, 'progress_opacity_effect'):
                self.progress_opacity_effect = QGraphicsOpacityEffect(self.progressBar)
                self.progressBar.setGraphicsEffect(self.progress_opacity_effect)

            # Handle text display
            if txt:
                # Reset opacity
                self.label_opacity_effect.setOpacity(1.0)
                self.label_3.setText(txt)
                # Create fade out animation
                self.fade_out = QPropertyAnimation(self.label_opacity_effect, b"opacity")
                self.fade_out.setDuration(3000)  # 3 second animation
                self.fade_out.setStartValue(1.0)
                self.fade_out.setEndValue(0.0)
                self.fade_out.setEasingCurve(QEasingCurve.Type.InOutQuad)
                
                # Only start fade out if not holding the message (for transcription)
                if not hold:
                    # Start fade out after 5 seconds
                    QTimer.singleShot(5000, self.fade_out.start)
                
                # Clear text after animation
                self.fade_out.finished.connect(lambda: self.label_3.setText(""))
                
            elif filename:
                self.label_3.setText(f"Downloading {filename}...")
                self.label_opacity_effect.setOpacity(1.0)
            
            # Handle button states
            if hold:
                self.pushButton.setEnabled(False)
                self.textEdit.setEnabled(False)
            
            if reset:
                self.pushButton.setEnabled(True)
                self.textEdit.setEnabled(True)
                
                # Create fade out animations for both elements
                self.fade_out_label = QPropertyAnimation(self.label_opacity_effect, b"opacity")
                self.fade_out_label.setDuration(3000)
                self.fade_out_label.setStartValue(1.0)
                self.fade_out_label.setEndValue(0.0)
                
                self.fade_out_progress = QPropertyAnimation(self.progress_opacity_effect, b"opacity")
                self.fade_out_progress.setDuration(3000)
                self.fade_out_progress.setStartValue(1.0)
                self.fade_out_progress.setEndValue(0.0)
                
                # Create animation group to run both animations together
                self.animation_group = QParallelAnimationGroup()
                self.animation_group.addAnimation(self.fade_out_label)
                self.animation_group.addAnimation(self.fade_out_progress)
                
                # Start animations
                self.animation_group.start()
                
                # Clean up after animations complete
                def cleanup():
                    self.label_3.setText("")
                    self.progressBar.setVisible(False)
                    self.progressBar.setProperty("value", 0)
                    # Reset opacities to 1.0 for next time
                    self.label_opacity_effect.setOpacity(1.0)
                    self.progress_opacity_effect.setOpacity(1.0)
                
                self.animation_group.finished.connect(cleanup)
            
            if percentage is not None:
                if not self.progressBar.isVisible():
                    self.progressBar.setVisible(True)
                    self.progress_opacity_effect.setOpacity(1.0)
                
                self.progressBar.setProperty("value", percentage)
                
                # If percentage reaches 100%, start fade out animation
                if percentage >= 100:
                    QTimer.singleShot(1000, lambda: self.display_message(reset=True))

        def toggle_persistent_toolbar(self):
            """Toggle whether the toolbar is persistent or not."""
            self.toolbar_persistent = not self.toolbar_persistent
            
            # Update window size based on toolbar persistence
            self.adjust_window_for_toolbar()
            
            # Show the toolbar if it's now persistent
            if self.toolbar_persistent:
                self.toolbar_widget.show()
                self.toolbar_widget.raise_()
                self.toolbar_visible = True
            elif not self.toolbar_visible:
                self.toolbar_widget.hide()
            
            self.display_message(txt=f"Persistent Toolbar: {'Enabled' if self.toolbar_persistent else 'Disabled'}")
            
        def adjust_window_for_toolbar(self):
            """Adjust window height based on toolbar persistence."""
            toolbar_height = self.toolbar_widget.height()
            current_size = self.size()
            
            if self.toolbar_persistent:
                # Ensure the window is tall enough to accommodate the toolbar without covering content
                self.setFixedHeight(300 + toolbar_height)
                # Adjust central widget positioning to make room for toolbar
                self.centralwidget.setGeometry(0, toolbar_height, self.width(), self.height() - toolbar_height)
            else:
                # Return to original size
                self.setFixedHeight(300)
                # Reset central widget positioning
                self.centralwidget.setGeometry(0, 0, self.width(), self.height())
            
        def keyPressEvent(self, event):
            if self.record_key_toggle:
                event.accept()
                self.textEdit.setReadOnly(False)
                key_text = self.get_key_name(event)
                self.pressed_keys.add(key_text)
                self.combination = "+".join(sorted(self.pressed_keys))
                self.textEdit.setText(self.combination)
                self.textEdit.setReadOnly(True)
                self.textEdit.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
            elif event.key() == Qt.Key.Key_Alt and not event.isAutoRepeat() and not self.toolbar_persistent:
                # Toggle toolbar visibility when Alt is pressed (not repeated)
                # but only if toolbar is not persistent
                self.toolbar_visible = not self.toolbar_visible
                if self.toolbar_visible:
                    self.toolbar_widget.show()
                    self.toolbar_widget.raise_()  # Bring to front
                else:
                    self.toolbar_widget.hide()
                    if self.current_menu:
                        self.current_menu.close()
                        self.current_menu = None
            super().keyPressEvent(event)
                
        def eventFilter(self, obj, event):
            """Handle mouse clicks and hover events."""
            if event.type() == self.MOUSE_PRESS and self.toolbar_visible and not self.toolbar_persistent:
                # Check if the click is outside the toolbar
                # but only hide if toolbar is not persistent
                try:
                    click_pos = event.globalPos()  # PyQt5
                except AttributeError:
                    click_pos = event.globalPosition().toPoint()  # PyQt6
                
                toolbar_rect = self.toolbar_widget.geometry()
                toolbar_global_rect = QtCore.QRect(
                    self.mapToGlobal(toolbar_rect.topLeft()),
                    self.mapToGlobal(toolbar_rect.bottomRight())
                )
                if not toolbar_global_rect.contains(click_pos):
                    # Check if the click is not on a menu
                    active_popup = QApplication.activePopupWidget()
                    if not (active_popup and active_popup.geometry().contains(click_pos)):
                        self.toolbar_widget.hide()
                        self.toolbar_visible = False
                        if self.current_menu:
                            self.current_menu.close()
                            self.current_menu = None
            elif (event.type() == QtCore.QEvent.Type.Enter and 
                  obj in self.button_menu_map and 
                  self.toolbar_visible and 
                  self.current_menu):
                # If a menu is open and mouse enters another button, switch menus
                current_button = None
                for button, menu in self.button_menu_map.items():
                    if menu == self.current_menu:
                        current_button = button
                        break
                
                if current_button != obj:  # Only switch if hovering a different button
                    self.current_menu.close()
                    menu = self.button_menu_map[obj]
                    pos = obj.mapToGlobal(QtCore.QPoint(0, obj.height()))
                    menu.popup(pos)
                    self.current_menu = menu
            return super().eventFilter(obj, event)
        
        def hide_toolbar(self):
            """Hide the toolbar when a menu is closed."""
            if not self.toolbar_persistent:
                self.toolbar_widget.hide()
                self.toolbar_visible = False

    app = QApplication(sys.argv)
    app.setQuitOnLastWindowClosed(False)
    app.setWindowIcon(QIcon(resource_path("media/Windows 1 Theta.png")))
    
    # Check if app is already running
    if is_already_running():
        # Send signal to bring existing window to front
        try:
            # If we're on Windows, use win32gui to activate the existing window
            if sys.platform == 'win32':
                if HAS_WIN32GUI:
                    # Find window by class name and title
                    def enum_windows_callback(hwnd, result_list):
                        if win32gui.IsWindowVisible(hwnd):
                            window_title = win32gui.GetWindowText(hwnd)
                            if window_title == "WinSTT":  # Match the window title
                                result_list.append(hwnd)
                        return True
                    
                    hwnd_list = []
                    win32gui.EnumWindows(enum_windows_callback, hwnd_list)
                    
                    if hwnd_list:
                        # Bring window to foreground
                        win32gui.ShowWindow(hwnd_list[0], 9)  # SW_RESTORE
                        win32gui.SetForegroundWindow(hwnd_list[0])
                else:
                    # If win32gui is not available, just show a message
                    logger.warning("win32gui module not found. Install with: pip install pywin32")
                    QMessageBox.warning(None, "WinSTT", "Another instance is already running. The pywin32 package is required to activate the existing window.")
            
            logger.info("An instance of WinSTT is already running. Exiting.")
            sys.exit(0)
        except Exception as e:
            logger.error(f"Error activating existing instance: {e}")
            # If activation fails, show message and exit
            QMessageBox.warning(None, "WinSTT", "An instance of WinSTT is already running.")
            sys.exit(0)
    
    window = Window()
    window.show()
    sys.exit(app.exec())